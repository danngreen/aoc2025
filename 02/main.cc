#include "input.hh"
#include "sample_input.hh"
#include <cstddef>
#include <iostream>
#include <numeric>
#include <set>

// Numbers that repeat are the product of a "base" and a "factor".
// The base is a sum of certain combinations of powers of 10: 10+1, 100+1, 100000+100+1, etc..
// The factor is in the range [10^(N-1), (10^N)-1]: [10,99], [100,999], [1000,9999],...
// Each base has a distinct factor range
// T

struct Form {
	int resulting_digits;	 // number of digits in the result: e.g. 123123 => 6
	int factor_digits;		 // number of digits in the factor: 2 => 10-99, 3 => 100-999, etc
	unsigned long long base; // base: 11, 101, 1001, 10101, etc
};

constexpr std::array<Form, 5> forms_p1{{
	{2, 1, 11},
	{4, 2, 101},
	{6, 3, 1001},
	{8, 4, 10001},
	{10, 5, 100001},
}};

// All formulas to make a repeating digit number with max 10 digits.
// This could be generated by combining powers of 10 in the sequence of series like:
// 10^0 + 10^1 + 10^2 + 10^3 + ...  + 10^10
// 10^0 + 10^2 + 10^4 + 10^6 + 10^8 + 10^10
// 10^0 + 10^3 + 10^6 + 10^9
// 10^0 + 10^4 + 10^8
// 10^0 + 10^5 + 10^10
// For each series, the Nth terms can be taken
constexpr std::array<Form, 17> forms_p2{{
	{2, 1, 11},
	{3, 1, 111},
	{4, 1, 1111},
	{5, 1, 11111},
	{6, 1, 111111},
	{7, 1, 1111111},
	{8, 1, 11111111},
	{9, 1, 111111111},
	{10, 1, 1111111111},
	{4, 2, 101},
	{6, 2, 10101},
	{8, 2, 1010101},
	{10, 2, 101010101},
	{6, 3, 1001},
	{9, 3, 1001001},
	{8, 4, 10001},
	{10, 5, 100001},
}};

constexpr unsigned num_digits(auto a) {
	if (a > 10'000'000'000)
		return 11;
	if (a > 1'000'000'000)
		return 10;
	if (a > 100'000'000)
		return 9;
	if (a > 10'000'000)
		return 8;
	if (a > 1'000'000)
		return 7;
	if (a > 100'000)
		return 6;
	if (a > 10'000)
		return 5;
	if (a > 1'000)
		return 4;
	if (a > 100)
		return 3;
	if (a > 10)
		return 2;
	return 1;
}

constexpr unsigned long pow10(unsigned x) {
	int r = 1;
	while (x--) {
		r *= 10;
	}
	return r;
}
static_assert(pow10(0) == 1);
static_assert(pow10(1) == 10);
static_assert(pow10(2) == 100);
static_assert(pow10(5) == 100000);

std::set<unsigned long long> ids;

// Finds the overlapping range between the ranges
// Multiplies each number in the overlapping range by rep
// Inserts that products into the ids set (if it's unique)
constexpr void
append_overlap(unsigned long ceil_a, unsigned long floor_b, unsigned long min, unsigned long max, unsigned long rep) {
	// return 0 if the ranges don't overlap
	if (ceil_a > max || floor_b < min)
		return;

	// Find overlapping range
	auto o_min = std::max(ceil_a, min);
	auto o_max = std::min(floor_b, max);

	for (auto x = o_min; x <= o_max; x++) {
		auto id = x * rep;
		ids.insert(id);
		printf("%lu\n", x * rep);
	}
}

constexpr void process(unsigned long long a, unsigned long long b) {

	auto digs_a = num_digits(a);
	auto digs_b = num_digits(b);

	printf("[%llu,%llu]: digs:%d-%d\n", a, b, digs_a, digs_b);
	for (auto f : forms_p1) {
		if (f.resulting_digits == digs_a || f.resulting_digits == digs_b) {
			auto min = pow10(f.factor_digits - 1);
			auto max = pow10(f.factor_digits) - 1;
			double div = f.base;

			unsigned long ceil_a = std::ceil(double(a) / div);
			unsigned long floor_b = std::floor(double(b) / div);

			printf("Check with base %llu: [%lu, %lu] overlaps? with [%lu, %lu]\n", f.base, ceil_a, floor_b, min, max);

			append_overlap(ceil_a, floor_b, min, max, f.base);
		}
	}
}

int main() {
	// Sample data:
	// for (auto [a, b] : sample_data) {
	// 	process(a, b);
	// }
	// unsigned long long cnt0 = std::accumulate(ids.begin(), ids.end(), 0);
	// std::cout << "Sample: " << cnt0 << "\n";

	ids.clear();
	for (auto [a, b] : data) {
		process(a, b);
	}
	unsigned long long cnt = std::accumulate(ids.begin(), ids.end(), 0);
	std::cout << "Part 1: " << cnt << "\n";
}
